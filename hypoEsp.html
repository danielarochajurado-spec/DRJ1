<!DOCTYPE html> <html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HypotheticalDDgame</title>
  <script src="https://unpkg.com/jspsych@7.2.1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-text@1.1.1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.1"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <link href="https://unpkg.com/jspsych@7.2.1/css/jspsych.css" rel="stylesheet" />

  <style>
    body { background: #0f1220; color: white; font-family: Arial, Helvetica, sans-serif; margin: 0; }
    #jspsych-target { min-height: 100vh; display:flex; align-items:center; justify-content:center; }
    .jspsych-content { max-width: 800px; text-align:center; font-size:18px; padding: 40px; }
    button.jspsych-btn { padding: 14px 22px; font-size:18px; border-radius:10px; border: none; cursor:pointer; margin:10px; }
    .left-btn { background:darkgray; color:black; }
    .right-btn { background:darkgray; color:black; }
    #saveExitBtn {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 10001; 
        cursor: pointer;
        background: transparent;
        color: black;
        border: 1px solid #283056;
        border-radius: 10px;
        padding: 10px 12px;
    }
  </style>
</head>
<body>
  <div id="jspsych-target"></div>
   <button id="saveExitBtn"> Guardar y salir </button>

<script type="module">
  // ===== FIREBASE IMPORT =====
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
  import { getFirestore, doc, getDoc, setDoc, collection, addDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

  // ===== FIREBASE CONFIG =====
  const firebaseConfig = {   
    apiKey: "AIzaSyBdiRWxsnpS55ZhgVAMR89FP7DTXOQ4WiA",
    authDomain: "discountinggame.firebaseapp.com",
    projectId: "discountinggame",
    storageBucket: "discountinggame.firebasestorage.app",
    messagingSenderId: "497209908113",
    appId: "1:497209908113:web:6e36f40f63b8154a44d830"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  window.db = db;
  let data_rows = []; // Variable global para almacenar los datos 

  // ===== FUNCIONES FIREBASE =====
function exportDataToExcel(participant_id) {
      const worksheet = XLSX.utils.json_to_sheet(data_rows);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Resultados');
      // Generate the filename using participant ID and date
      const date = new Date().toISOString().replace(/[:.]/g, "-").replace("T", "_").slice(0, 19);
      const filename = `hypoDDGame_results_${participant_id}_${date}.xlsx`;

      // Write and download the Excel file
      XLSX.writeFile(workbook, filename);
    }
    
    async function saveDataToFirebase(participant_id, data_rows) {
        try {
          const date = new Date().toISOString().replace(/[:.]/g, "-").replace("T", "_").slice(0, 19);
          const docId = `hypoDDGame_${date}_${participant_id}`;
          const docRef = doc(db, "results", docId);

          await setDoc(docRef, {
            participant_id,
            date,
            data: data_rows
          });
          console.log('✅ Data successfully sent to Firestore');
         } catch (error) {
          console.error('❌ Error sending data to Firestore:', error);
        }
      }

      async function saveAndExit(jsPsych) {     
        console.log('Saving and exiting...');     
        // Retrieve the participant ID     
        let participant_id = jsPsych?.data?.get()?.values()[0]?.participant_id || localStorage.getItem('participant_id') || "unknown";      
        exportDataToExcel(participant_id);      
        await saveDataToFirebase(participant_id, data_rows);      
        // Save data to localStorage as a backup      
        localStorage.setItem('DDGame', JSON.stringify(data_rows));      
        // Redirect or show a confirmation message      
        alert('Your progress has been saved. The game will now end.');      
        window.location.href = "index.html"; // Redirect to the main page or a thank-you page
        }    
        window.saveAndExit = saveAndExit; // Hacer accesible globalmente

      async function markTaskComplete() {
        const pid = localStorage.getItem('participantId');
        const taskId = localStorage.getItem('currentTask');
        const ref = doc(db, "participants", pid);
        const snap = await getDoc(ref);
        let data = snap.exists() ? snap.data() : { completed: {} };

        data.completed[taskId] = true;
        await setDoc(ref, data);
      }
      window.markTaskComplete = markTaskComplete;
      document.addEventListener('gameComplete', markTaskComplete);

  // ============================
  // Variables globales iniciales
  // ============================
      let fixed_delays = [500, 875, 1531, 2679, 4689];
      let A_s = 6000;
      let A_l = 15000;
      let stepSize = 2000;
      let total_game_score = 0;
      let last_choice_data = {};

  // ============================
  // Inicializar jsPsych
  // ============================
  const jsPsych = initJsPsych({
    display_element: 'jspsych-target',
    override_safe_mode: true,
        on_finish: async () => {
          let participant_id = jsPsych?.data?.get()?.values()[0]?.participant_id || localStorage.getItem('participant_id') || "unknown";
          exportDataToExcel(participant_id);
          await saveDataToFirebase(participant_id, data_rows);
          await markTaskComplete();
          window.location.href = "index.html";
        }
      });
      let jsPsychInstance; // Variable global para almacenar la instancia de jsPsych
 
  const saveExitBtn = document.createElement('button');
  saveExitBtn.id = 'saveExitBtn';
  saveExitBtn.textContent = 'Guardar y Salir';
  saveExitBtn.style.position = 'fixed';
  saveExitBtn.style.top = '10px';
  saveExitBtn.style.right = '10px';
  saveExitBtn.style.zIndex = '10001';
  saveExitBtn.style.backgroundColor = 'transparent';
  saveExitBtn.style.color = 'white';
  saveExitBtn.style.padding = '10px 20px';
  saveExitBtn.style.borderRadius = '8px';
  saveExitBtn.style.cursor = 'pointer';
  saveExitBtn.onclick = () => saveAndExit(jsPsych); // Usar la instancia global
  document.body.appendChild(saveExitBtn);

  // ============================
  // BuildInitialTrials: ID + instrucciones
  // ============================
  function buildInitialTrials(jsPsych_instance) {
    const participant_id_trial = {
      type: jsPsychSurveyText,
      questions: [{
        prompt: '<h2>Bienvenido al experimento.</h2><p>Si ya leyó y firmo el consentimiento informado, escriba su número de participante para iniciar. </p><p> De lo contrario, llame al investigador.</p>',      
        placeholder: 'Ex: 101',
        required: true,
        name: 'participant_id'
      }],
      on_finish: (data) => {
        const participant_id = data.response.participant_id;
        if (participant_id) {
          jsPsych_instance.data.addProperties({ participant_id });
          localStorage.setItem('participant_id', participant_id);
        }
      }
    };

    const instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `<h2>Instrucciones</h2>
        <p>

        En esta tarea usted tendra que responder varias perguntas hipotéticas.
         En cada pregunta, deberá elegir entre esperar poco tiempo para jugar poco 
            o esperar más tiempo para jugar durante un intervalo tres veces mayor.
            Lea cada opción con atención, pues el tiempo de espera 
            puede cambiar.

         No hay respuestas correctas o incorrectas. Seleccione la opción que
        probablemente usted escogería si realmente estuviera jugando.        </p>
        <p>
        Haga click en  “Comenzar” para iniciar la tarea.
        </p>`,
      choices: ['Comenzar'],
    };

    return [participant_id_trial, instructions];
  }

  // ============================
  // Pausa en blanco (ITI 0.5s)
  // ============================
  const blank_screen = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: '',
    choices: "NO_KEYS",
    trial_duration: 500,
    data: { trial_type: 'blank' }
  };

  
  // ============================
  // freeTrial: pregunta central (ajusta delayState.large)
  // ============================
  function freeTrial(delayState, current_delay_small, condition_index, response_type, trial_number_tracker, p_tracker) {
    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        const currentScore = 0; // no hay juego, pero mantenemos la etiqueta
        return `
          <div style="margin-bottom:20px;">
            <p><strong> ¿Qué preferiría?</strong></p>
            </div>
        `;
      },
      choices: () => [
        `Esperar ${(delayState.large / 1000).toFixed(1)} segundos para jugar más tiempo`,
        `Esperar ${(current_delay_small / 1000).toFixed(1)} segundos para jugar menos tiempo`
      ],
      button_html: [
        `<button class="jspsych-btn left-btn">%choice%</button>`,
        `<button class="jspsych-btn right-btn">%choice%</button>`
      ],
      on_finish: (data) => {
        const choice = data.response === 0 ? 'left' : 'right';
        const choice_num = data.response === 0 ? 1 : 2;

        // registrar elección
        response_type.push(choice);
        trial_number_tracker.count++;

            // Keep a history of last two choices
            if (!p_tracker.last_two) p_tracker.last_two = [];

            // Add the current choice to the history
            p_tracker.last_two.push(choice);

            // Keep only the last 2 entries
            if (p_tracker.last_two.length > 2) p_tracker.last_two.shift();

            // Check if the last two choices were the same
            if (p_tracker.last_two.length === 2 && p_tracker.last_two[0] === 'left' && p_tracker.last_two[1] === 'left') {
              stepSize += 1000; 
              if (stepSize > 6000) stepSize = 6000;
              console.log(`Step size increased to ${stepSize}`);
            }
            if (p_tracker.last !== null && choice !== p_tracker.last) {
              stepSize = Math.max(1000, stepSize - 2000);
              console.log(`Preference changed. Step size decreased to ${stepSize}`);
            }

            if (choice === 'left') {
              delayState.large += stepSize;
            } else {
              delayState.large = Math.max(delayState.large - stepSize, current_delay_small);
            }

            // actualizar p_tracker como en tu código original
            if (p_tracker.last !== null) {
              if (choice !== p_tracker.last) p_tracker.p_changes++;
              else if (choice === 'right') p_tracker.no_change++;
            }
            p_tracker.last = choice;

        // guardar fila
        last_choice_data = {
          condition: fixed_delays[condition_index],
          A_l: A_l,
          A_s: A_s,
          choice: choice,
          choice_num: choice_num,
          delay_large: delayState.large,
          delay_small: current_delay_small,
          latency: data.rt,
          trial_number: trial_number_tracker.count
        };
        data_rows.push(last_choice_data);

        // debug en consola
        // console.log('choice', last_choice_data);
      }
    };
  }

  // ============================
  // Placeholders: createDelay y createMatch3Trial (sin esperas reales)
  // - Mantienen la estructura, pero no producen demora real ni juego.
  // ============================
  function createDelay(delayState, current_delay_small) {
    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        // Solo un placeholder visual breve (0 ms)
        const last = jsPsych.data.get().last(1).values()[0];
        const color = last && last.response === 0 ? '#00b050' : '#c00000';
        // NO cambiamos background de manera persistente (queremos fondo blanco)
        return `<div style="height:1px;"></div>`;
      },
      choices: [], // sin botones
      trial_duration: 0,
      data: { trial_type: 'delay_placeholder' },
      on_finish: () => { /* no-op */ }
    };
  }

  function createMatch3Trial() {
    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => `<div style="height:1px;"></div>`,
      choices: [],
      trial_duration: 0,
      data: { trial_type: 'match3_placeholder' }
    };
  }

  // ============================
  // ITI (otra versión, aunque usamos blank_screen para 0.5s)
  // ============================
  function createITI() {
    return {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '',
      choices: "NO_KEYS",
      trial_duration: 1000,
      data: { trial_type: 'iti' }
    };
  }

  // ============================
  // BuildConditionsLoop: crea un timeline por cada fixed_delay
  // ============================
  function buildConditionsLoop() {
    const condition_timelines = [];

    for (let i = 0; i < fixed_delays.length; i++) {
      const current_delay_small = fixed_delays[i];
      const initial_delay_large = fixed_delays[i] * 3;
      const delayState_local = { large: initial_delay_large }; // copia local por condición
      const response_type_local = [];
      const trial_number_tracker_local = { count: 0 };
      const p_tracker_local = { p_changes: 0, no_change: 0, last: null };
      let loop_counter = 0;

      // Timeline para esta condición
      const loop_timeline = {

            timeline: [
              freeTrial(delayState_local, current_delay_small, i, response_type_local, trial_number_tracker_local, p_tracker_local),
              blank_screen // ITI entre cada pregunta
            ],
            loop_function: function(data) {

              loop_counter++;
              console.log(`Loop iteration ${loop_counter} for condition ${i}, delay_large=${delayState_local}`);
              // detener cuando cualquiera de las condiciones se cumple
              const stop = (
                (p_tracker_local.p_changes > 3 && response_type_local.length >= 3) ||
                (p_tracker_local.no_change > 6) ||
                (response_type_local.length >= 8)
              );
              // debug
              // console.log(`Cond ${i} - iter ${loop_counter} - p_changes: ${p_tracker_local.p_changes}, no_change: ${p_tracker_local.no_change}, responses: ${response_type_local.length}, delay_large: ${delayState_local.large}`);
              return !stop; // devuelve true para repetir; devolvemos !stop según jsPsych (loop si true)
            }
          ,

          // Pequeña pausa final de la condición
          blank_screen
        
      };

      condition_timelines.push(loop_timeline);
    }

    return condition_timelines;
  }

  // ============================
  // Mensaje final
  // ============================
  const final_message = {
    type: jsPsychHtmlButtonResponse,
    stimulus: () => `<p>Tarea finalizada!</p><p>Gracias por su participación</p>`,
    choices: ['Cerrar']
  };

  // ============================
  // Main timeline y run
  // ============================
  const main_timeline = [
    ...buildInitialTrials(jsPsych),
    ...buildConditionsLoop(),
    final_message
  ];

  jsPsych.run(main_timeline);

</script>
</body>
</html>
